const express = require("express");
const axios = require('axios').default;
const router = express.Router();
const { v4: uuidv4 } = require('uuid');
const Transaction = require('../models/transaction');
const detailsSchema = require('../validation');
const jwt = require('jsonwebtoken');
require('dotenv').config({ path: './.env' });
const makePayment = require('../MTN/makePayment');
const makeTransfers = require('../MTN/makeDisbursement');

/**
 * @swagger
 * components:
 *   schemas:
 *     Transaction:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *           description: The auto-generated id of the transaction
 *         transaction_id:
 *           type: string
 *           description: The autogenerated id of the incoming transaction from customer
 *         order_id:
 *           type: string
 *           description: The autogenerated id of the order
 *         amount:
 *           type: number
 *           description: The billing amount for the customer
 *         payment:
 *           type: object
 *           description: Object containing payments
 *       example:
 *         id: d5fE_asz
 *         transaction_id: 12345678
 *         order_id: 4543932xb4534343
 *         amount: 101
 *         payment: {'restaurant':{'name':'Stages','amount':90,'acc_number':0202,'transaction_id':0012345},'driver':{'name':'Kwame','amount':1,'acc_number':0202,'transaction_id':0012345},'company':{'name':'Dcompany','amount':9,'acc_number':0202,'transaction_id':0012345}}
 *     Details:
 *       type: object
 *       required:
 *         - amount_payable
 *         - amount
 *         - entities
 *       properties:
 *         amount_payable:
 *           type: number
 *           description: The amount the user would pay. Includes transaction charge
 *         amount:
 *           type: number
 *           description: Actual amount that will be returned to the billing entities
 *         entities:
 *           type: object
 *           description: A json object specifying the percentages each biling entity, their account number and the percentage they receive
 *       example:
 *         amount_payable: 101.00
 *         amount: 100
 *         entities: {'restaurant':{'name':'Stages','acc_number':0202,'percentage':0.9},'driver':{'name':'Kwame','acc_number':0202,'percentage':0.01},'company':{'name':'Dcompany','acc_number':0202,'percentage':0.09}}
 */

 /**
  * @swagger
  * tags:
  *   name: Transactions
  *   description: The Transaction management
  */

 /**
 * @swagger
 * /api/transaction:
 *   post:
 *     summary: Create a new Transaction
 *     tags: [Transactions]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/Details'
 *     responses:
 *       200:
 *         description: The Transaction was successfully created
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Transaction'
 *       500:
 *         description: Some server error
 */


 router.post("/transaction/",async(req,res)=>{
    try {
        await detailsSchema.validateAsync(req.body);
        const {amount_payable, amount,order_id, entities} = req.body;
        try {
            let {key} = jwt.verify(req.headers.authorization,process.env.JWT_SECRET);
            if(key!=process.env.DPAY_SECRET) return res.status(403).send({status:'Unathorized'});
        } catch (error) {
            return res.status(401).send({status:'Unathorized'});
        }
        


    
        const {restaurant,driver,company} = entities;
        const newTransaction = new Transaction(
        {
            'transaction_id':uuidv4(),
            'order_id':uuidv4(),
            'payment':{
                'restaurant':{
                    'name': restaurant.name,
                    'amount': parseFloat((amount*restaurant.percentage).toFixed(2)),
                    'transaction_id':uuidv4(),
                },
                'driver':{
                    'name': driver.name,
                    'amount': parseFloat((amount*driver.percentage).toFixed(2)),
                    'transaction_id':uuidv4(),
                },
                'company':{
                    'name': company.name,
                    'amount': parseFloat((amount*company.percentage).toFixed(2)),
                    'transaction_id':uuidv4(),
                },
            }
        });
        newTransaction.save();
        return res.send(newTransaction);
    } catch (error) {
        return res.status(500).send(error);
    }
 })


 router.post("/bubble/transaction/",async(req,res)=>{
    try {
        // await detailsSchema.validateAsync(req.body);
        const {amount_payable, amount,
                restaurantName, restaurantAccNum, restaurantPercentage,
                driverName, driverAccNum, driverPercentage,
                companyName, companyAccNum, companyPercentage,} = req.body;
        try {
            let {key} = jwt.verify(req.headers.authorization,process.env.JWT_SECRET);
            if(key!=process.env.DPAY_SECRET) return res.status(403).send({status:'Unathorized'});
        } catch (error) {
            return res.status(401).send({status:'Unathorized'});
        }

        const paymentDetails = await makePayment("0248974853",amount_payable.toString());
        const transferDetails = await makeTransfers(
            [restaurantAccNum,driverAccNum,companyAccNum],
            [(amount*restaurantPercentage).toFixed(2),(amount*driverPercentage).toFixed(2),(amount*companyPercentage).toFixed(2)],
            [restaurantName,driverName,companyName]
        );

        const newTransaction = new Transaction(
        {
            'transaction_id':paymentDetails.financialTransactionId,
            'amount': amount,
            'order_id':Date.now(),
            'payment':{
                'restaurant':transferDetails[0],
                'driver':transferDetails[1],
                'company':transferDetails[2],
            }
        });
        newTransaction.save();
        return res.send({
            transaction_id:newTransaction.transaction_id,
            order_id: newTransaction.order_id,
            restaurantName:restaurantName,
            restaurantAmount:newTransaction.payment.restaurant.amount,
            restaurantTid:newTransaction.payment.restaurant.financialTransactionId,
            restaurantMessage:newTransaction.payment.restaurant.payerMessage,
            driverName:driverName,
            driverAmount:newTransaction.payment.driver.amount,
            driverTid:newTransaction.payment.driver.financialTransactionId,
            driverMessage:newTransaction.payment.driver.payerMessage,
            companyName:companyName,
            companyAmount:newTransaction.payment.company.amount,
            companyTid:newTransaction.payment.company.financialTransactionId,
            companyMessage:newTransaction.payment.company.payerMessage,
        });
    } catch (error) {
        // throw error;
        return res.status(500).send(error);
    }
 })

 router.post('/token/',(req,res)=>{
     if(req.body.key==process.env.DPAY_SECRET){
         res.json({
        status:'success',
        token: jwt.sign({ key: req.body.key }, process.env.JWT_SECRET)
        })
     }else{
         res.status(401).send({status:'Unathorized'});
     }
    
 });

 module.exports = router;